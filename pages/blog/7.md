---
layout: blog
type: md
bid: 7
title: ç¬¬ä¸€æ¬¡ AK äº†åŠ›æ‰£å‘¨èµ›ğŸ‰
time: 2022-03-06T10:23:24.205Z
tags:
  - ç®—æ³•
  - æ•°æ®ç»“æ„
---

å‰å‡ æ¬¡åŠ›æ‰£å‘¨èµ›ä¸€èˆ¬æœ€å¤šåªèƒ½åšå®Œå‰ä¸‰é¢˜ï¼Œæ²¡æƒ³åˆ°[è¿™æ¬¡çš„å‘¨èµ›](https://leetcode-cn.com/contest/weekly-contest-283/)ç«Ÿç„¶æ‹¿ä¸‹äº†ç¬¬å››é¢˜ï¼Œç¬¬ä¸€æ¬¡ AK äº†ã€‚ğŸ¥³

![leetcode-ranking](/images/blog/7/leetcode-ranking.webp)

è™½ç„¶ä¸»è¦åŸå› æ˜¯åˆšå¥½åœ¨å‰ä¸ä¹…åšäº†è·Ÿç¬¬å››é¢˜çŸ¥è¯†ç‚¹æœ‰å…³çš„é¢˜ç›®ï¼Œä½†è¿˜æ˜¯å¾ˆå¼€å¿ƒï¼Œå†™å†™è§£é¢˜æ€è·¯çºªå¿µä¸€ä¸‹ã€‚

### ç¬¬ä¸€é¢˜ [2194. Excel è¡¨ä¸­æŸä¸ªèŒƒå›´å†…çš„å•å…ƒæ ¼](https://leetcode-cn.com/problems/cells-in-a-range-on-an-excel-sheet/)

æœ¬é¢˜æ¯”è¾ƒç®€å•ï¼Œåªè¦æŒæ¡äº†æœ€åŸºæœ¬çš„æ•°å­—ã€å­—ç¬¦ã€å­—ç¬¦ä¸²çš„è½¬æ¢æ–¹æ³•å°±èƒ½åšå‡ºæ¥ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```golang
func cellsInRange(s string) []string {
	col1, row1, col2, row2 := s[0], s[1], s[3], s[4]
	ans := []string{}
	cell := make([]byte, 2)
	for c := col1; c <= col2; c++ {
		for r := row1; r <= row2; r++ {
			cell[0], cell[1] = c, r
			ans = append(ans, string(cell))
		}
	}
	return ans
}
```

### ç¬¬äºŒé¢˜ [2195. å‘æ•°ç»„ä¸­è¿½åŠ  K ä¸ªæ•´æ•°](https://leetcode-cn.com/problems/append-k-integers-with-minimal-sum/)

æœ¬é¢˜å¯ä»¥é‡‡ç”¨è´ªå¿ƒç­–ç•¥ã€‚è¦ä½¿è¿½åŠ  K ä¸ªæ•´æ•°ä¹‹åç»“æœæ•°ç»„çš„å…ƒç´ å’Œæœ€å°ï¼Œåªè¦æ¯æ¬¡è¿½åŠ å…ƒç´ æ—¶é€‰æ‹©è¿½åŠ å…è®¸çš„æœ€å°çš„æ•°å­—å³å¯ã€‚

ä¾‹å¦‚ `nums = [1, 4], K = 2` çš„æƒ…å†µä¸‹ï¼Œå…è®¸è¿½åŠ çš„æ•°å­—æœ‰ `2`ã€`3`ã€`å¤§äº 4 çš„æ•´æ•°`ï¼Œå…¶ä¸­æœ€å°çš„ä¸¤ä¸ªæ•°å­—æ˜¯ `2` å’Œ `3`ï¼Œé‚£ä¹ˆå°† `2` å’Œ `3` è¿½åŠ åˆ° `nums` ä¸­å³å¯ä½¿ `nums` çš„å…ƒç´ å’Œæœ€å°ã€‚

ç»è¿‡è§‚å¯Ÿå¯å‘ç°ï¼Œå¾ˆå¤šæ—¶å€™è¦è¿½åŠ çš„æ•°å­—ä¼šæ˜¯ä¸€ç»„å…¬å·®ä¸º 1 çš„ç­‰å·®æ•°åˆ—ï¼Œä¾‹å¦‚ `3, 4, 5, ..., 80`ã€‚æ­¤æ—¶å¦‚æœä¸€ä¸ªæ•°ä¸€ä¸ªæ•°åœ°è®¡ç®—çš„è¯æ—¶é—´æ•ˆç‡è¾ƒä½ï¼Œå¯ä½¿ç”¨ç­‰å·®æ•°åˆ—çš„æ±‚å’Œå…¬å¼æ¥è®¡ç®—è¿™ç»„ç­‰å·®æ•°åˆ—çš„å’Œã€‚

ä»£ç å¦‚ä¸‹ï¼š

```golang
import "sort"

func sn(a0, n int) int64 {
	return int64(n)*int64(a0) + int64(n)*int64(n-1)/2
}

func minimalKSum(nums []int, k int) int64 {
	sort.Slice(nums, func(i, j int) bool {
		return nums[i] < nums[j]
	})
	sum := int64(0)
	prev := 0
	for _, num := range nums {
		vacancy := num - prev - 1
		if vacancy > 0 {
			if vacancy > k {
				return sum + sn(prev+1, k)
			} else {
				sum += sn(prev+1, vacancy)
				k -= (num - prev - 1)
			}
		}
		prev = num
	}
	return sum + sn(nums[len(nums)-1]+1, k)
}
```

### ç¬¬ä¸‰é¢˜ [2196. æ ¹æ®æè¿°åˆ›å»ºäºŒå‰æ ‘](https://leetcode-cn.com/problems/create-binary-tree-from-descriptions/)

æœ¬é¢˜æ„Ÿè§‰æ¯”ç¬¬äºŒé¢˜è¿˜ç®€å•ã€‚ä¸»è¦æ€è·¯æ˜¯é€šè¿‡ä¸€ä¸ª `map` æŠŠèŠ‚ç‚¹å€¼æ˜ å°„åˆ°å¯¹åº”çš„èŠ‚ç‚¹ç»“æ„ä½“ï¼Œåœ¨éå† `descriptions` å³å¯ç®€å•å¿«é€Ÿåœ°ç”Ÿæˆæ•´æ£µæ ‘ã€‚

åœ¨éå†ä¸­å¯ä»¥æ ‡è®°ä¸€ä¸‹æ‹¥æœ‰çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼Œéå†å®Œæˆåæ²¡è¢«æ ‡è®°è¿‡çš„èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```golang
func createBinaryTree(descriptions [][]int) *TreeNode {
	nodes := map[int]*TreeNode{}
	marked := map[int]bool{}

	for _, description := range descriptions {
		parent, child, isLeft := description[0], description[1], description[2]
		if nodes[parent] == nil {
			nodes[parent] = &TreeNode{Val: parent}
		}
		if nodes[child] == nil {
			nodes[child] = &TreeNode{Val: child}
		}
		if isLeft == 1 {
			nodes[parent].Left = nodes[child]
		} else {
			nodes[parent].Right = nodes[child]
		}
		marked[child] = true
	}

	for nodeVal, node := range nodes {
		if !marked[nodeVal] {
			return node
		}
	}
	return nil
}
```

### ç¬¬å››é¢˜ [2197. æ›¿æ¢æ•°ç»„ä¸­çš„éäº’è´¨æ•°](https://leetcode-cn.com/problems/replace-non-coprime-numbers-in-array/)

æœ¬é¢˜å…³é”®çš„åœ°æ–¹åœ¨äºæ€ä¹ˆæ±‚æœ€å¤§å…¬çº¦æ•°å’Œæœ€å°å…¬å€æ•°ã€‚

æœ€å°å…¬å€æ•°ç­‰äºä¸¤æ•°ä¹‹ç§¯é™¤ä»¥ä¸¤æ•°çš„æœ€å¤§å…¬çº¦æ•°ï¼Œè€Œæœ€å¤§å…¬çº¦æ•°å¯ä»¥ä½¿ç”¨è¾—è½¬ç›¸é™¤æ³•æ±‚å¾—ã€‚å…³äºè¾—è½¬ç›¸é™¤æ³•å¯ä»¥å‚è€ƒæˆ‘ä¹‹å‰å†™çš„[è¿™ç¯‡åšå®¢](/blog/6)ã€‚

è§£å†³äº†æ±‚æœ€å°å…¬å€æ•°çš„é—®é¢˜ä¹‹åæ¥ä¸‹æ¥çš„äº‹æƒ…å°±ç®€å•äº†ã€‚ä¸»è¦æ€è·¯ä¸ºå®šä¹‰ä¸€ä¸ªæ ˆï¼Œåœ¨æ•°å­—å…¥æ ˆçš„æ—¶å€™åˆ¤æ–­è¯¥æ•°å­—ä¸æ ˆé¡¶æ•°å­—æ˜¯å¦åº”è¯¥è¢«æ›¿æ¢ä¸ºä¸¤æ•°çš„æœ€å°å…¬å€æ•°ã€‚æ˜¯åˆ™å¼¹å‡ºæ ˆé¡¶æ•°å­—ï¼Œå°†è¦å…¥æ ˆçš„æ•°å­—æ”¹ä¸ºä¸¤æ•°çš„æœ€å°å…¬å€æ•°ï¼Œå¹¶é‡å¤å‰é¢çš„åˆ¤æ–­æ­¥éª¤ï¼›å¦åˆ™ç›´æ¥å°†è¯¥æ•°å­—å…¥æ ˆã€‚

åœ¨ä»£ç å®ç°ä¸­ï¼Œå¯ä»¥å°†åŸæ•°ç»„ `nums` ä½œä¸ºæ ˆã€‚ç”±äºè¿™ä¸ªæ ˆæ‰€ä½¿ç”¨çš„ç©ºé—´ä¸€å®šä¸ä¼šè¶…å‡º `nums` å·²éå†çš„ç©ºé—´ï¼Œå› æ­¤ä¸ä¼šå½±å“åˆ° `nums` çš„éå†ã€‚è¿™ä¸ªå°æŠ€å·§å¯ä»¥èŠ‚çœæ‰é¢å¤–å®šä¹‰ä¸€ä¸ªæ ˆæ‰€éœ€çš„ç©ºé—´ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```golang
func gcd(a, b int) int {
	for b != 0 {
		a, b = b, a%b
	}
	return a
}

func lcm(a, b int) int {
	return a * b / gcd(a, b)
}

func replaceNonCoprimes(nums []int) []int {
	// ä½¿ç”¨ nums æ•°ç»„ä½œä¸ºæ ˆ
	top := 0
	for i := 1; i < len(nums); i++ {
		num := nums[i]
		if gcd(nums[top], num) == 1 {
			top++
			nums[top] = num
			continue
		}
		for top >= 0 && gcd(nums[top], num) > 1 {
			num = lcm(nums[top], num)
			top--
		}
		top++
		nums[top] = num
	}
	return nums[:top+1]
}
```
