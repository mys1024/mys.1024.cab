---
layout: blog
type: md
bid: 16
title: 如何锁定一个前端项目的环境版本
time: 2025-07-19T09:49:17.780Z
tags:
  - 技术
  - 前端
  - JavaScript
---

你是否经历过这样的场景：在别人的电脑上运行得好好的前端项目，到了自己的电脑上却报出各种莫名其妙的错误，甚至于连项目都跑不起来？

问题的根源，常常在于环境的不一致。对于一个前端项目（或者说 Node.js 项目），以下三样东西是最重要的环境要素：

- Node.js
- 包管理器
- 依赖

要让一个前端项目可以在每个开发人员的机器上顺利且完美地跑起来，就应该保证这三样东西是稳定且一致的。而实现这个目标的手段则是版本锁定。

## 锁定 Node.js 版本

我们可以通过 Node.js 的版本管理器实现锁定 Node.js 的版本，例如 `nvm`、`fnm`、`volta` 等。

以我常用的 fnm 为例，锁定 Node.js 版本的步骤如下：

1. 在项目的根目录创建 `.node-version` （或 `.nvmrc`）文件，在其中指定当前项目需要使用的 Node.js 版本：

    ```
    v24.2.0
    ```

2. 在项目根目录执行 `fnm use` 即可切换到指定的 Node.js 版本。如果配置好了 Shell Hook 则可以省去这一步，fnm 会在进入项目根目录时自动切换到对应的 Node.js 版本。

## 锁定包管理器版本

包管理器版本的可能是最受忽视的。原因可能在于 npm 通常随着 Node.js 一起安装，在 Node.js 版本一致的前提下，npm 的版本也相对一致。

但对于使用 pnpm 的项目来说，由于 pnpm 通常的安装方法是 `npm i -g pnpm`，会导致每个开发人员根据 pnpm 安装时间的不同，安装到的 pnpm 版本也不相同，进而导致一个项目 pnpm 的版本混乱。

最经典的问题就是低版本的 pnpm 不兼容高版本 pnpm 生成的 `pnpm-lock.yaml`，低版本 pnpm 执行 `pnpm i` 时会忽略并覆盖高版本的 `pnpm-lock.yaml`，导致一个项目的 `pnpm-lock.yaml` 文件总是变来变去（注意 `lockfileVersion` 的变化）：

![lock](/images/blog/16/lock.png)

而被反复覆盖的 `pnpm-lock.yaml` 也失去了锁定依赖的作用。因此不稳定的 pnpm 就是前端项目中最大的不稳定的环境因素。

要实现锁定一个项目 pnpm 的版本，可以通过 `corepack` 实现。corepack 是一个包管理器的包管理器，可以管理 pnpm 和 yarn 的版本。

corepack 从 Node.js 的 v16.9.0 版本开始，会跟随 Node.js 一起安装。因此对于我们目前常用的 Node.js 版本，corepack 基本都可以直接启用。从 Node.js 的 v25 版本开始，Node.js 不再捆绑安装 corepack，但我们还可以通过 `npm i -g corepack` 来安装 corepack。

通过 corepack 锁定 pnpm 版本的步骤如下：

1. 启用 corepack（只需要执行一次就可以让 corepack 保持全局开启）：

    ```sh
    corepack enable
    ```

2. 在需要锁定 pnpm 版本的项目的 `package.json` 中指定 pnpm 版本：

    ```json
    {
      "packageManager": "pnpm@9.15.2"
    }
    ```

3. 此时在此项目的根目录下执行 pnpm 命令会自动使用我们指定的版本：

    ```sh
    pnpm -v # 打印 9.15.2
    ```

## 锁定依赖版本

当我们通过 `pnpm i xxx` 安装依赖时，在 `package.json` 中会新增以下记录：

```json
{
  "dependencies": {
    "xxx": "^主版本号.次版本号.修订号"
  }
}
```

假设这个版本号是 `^1.2.3`，则其中开头的 `^` 表示这个依赖的实际版本只要满足`>=1.2.3 <2.0.0` 即可。

这种设计可能是为了让项目的依赖尽量升级次版本和修订版本。因为根据语义化版本的约定，引入新功能时应该增加次版本号，修复 Bug 时应该增加修订号，而增加修订号和次版本号时都不能引入破坏性改动。让依赖升级次版本号和修订号可以在不破坏现有功能的情况下获取到依赖的新功能和 Bug 修复。

然而这仅仅是理想情况。实际情况是依赖在次版本号甚至修订号中出现破坏性改动屡见不鲜。因此为了保证一个项目中依赖的稳定性，我们需要锁定依赖的版本。

最简单的方法是在 `package.json` 中将所有依赖的版本都固定，例如去掉版本号开头的 `^`。这种办法确实在一定程度上可以实现锁定依赖版本。但要说这样就可以高枕无忧了，那倒也不一定。

如果依赖源由于 Bug 甚至是恶意的目的，在我们获取相同版本号的依赖时，返回的是不同的依赖文件，此时在 `package.json` 中固定依赖版本的方法就无效了。

为了解决这个问题，包管理器的 lock 文件应运而生，例如 npm 的 `package-lock.json`，pnpm 的 `pnpm-lock.yaml`。lock 文件通过记录依赖的精确版本号和哈希校验值，可以让包管理器保证实际安装的依赖没有经过篡改。通过 lock 文件锁定依赖的版本是最为可靠的。

以下命令可以让包管理器严格遵守 lock 文件来安装依赖：

```sh
# npm
npm ci
# pnpm
pnpm install --frozen-lockfile
```

由于包管理器会自动生成和检查 lock 文件，所以实际上其实并不太需要我们操心。

我们要做的只有两点：

1. 确保一个项目使用相同版本的包管理器，避免由于包管理器版本不兼容，导致 lock 文件被反复覆盖。

2. 确保 lock 文件的变动提交到 `git` 或 `svn`，而不是将 lock 文件排除在版本控制之外。

## 结语

上面虽然主要介绍了 fnm + corepack 的方案，但这个方案并非唯一解。

工具只是达成目标的手段，我们的目标是要保证前端项目的 Node.js、包管理器、依赖的稳定且一致。
