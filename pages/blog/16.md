---
layout: blog
type: md
bid: 16
title: 锁定前端项目环境：Why & How
time: 2025-07-19T09:49:17.780Z
tags:
  - 技术
  - 前端
  - JavaScript
---

你是否有过这样的经历：在别人的电脑上运行得好好的项目，到了自己的电脑上却报出各种莫名其妙的错误，甚至于连项目都跑不起来？

问题的根源，常常在于环境的不一致。对于一个前端项目（或者说 Node.js 项目），以下三样东西是最重要的环境要素：

- Node.js
- 包管理器
- 依赖

要让一个前端项目可以在每个开发人员的机器上顺利且完美地跑起来，就应该保证这三样东西是稳定且一致的。而实现这个目标的手段则是版本锁定。

## 锁定 Node.js 版本

我们可以通过 Node.js 的版本管理器实现锁定 Node.js 的版本，例如 `nvm`、`fnm`、`volta` 等。

以我常用的 fnm 为例，锁定 Node.js 版本的步骤如下：

1. 在项目的根目录创建 `.node-version` （或 `.nvmrc`）文件，在其中指定当前项目需要使用的 Node.js 版本：

    ```
    v24.2.0
    ```

2. 在项目根目录执行 `fnm use` 即可切换到指定的 Node.js 版本。如果配置好了 fnm 的 Shell Hook 则可以省去这一步，fnm 会在进入项目根目录时自动切换到对应的 Node.js 版本。

## 锁定包管理器版本

包管理器的版本是最受忽视的。原因可能在于 npm 与 Node.js 捆绑安装，在 Node.js 版本一致的前提下，npm 的版本也通常一致。

但对于使用 pnpm 的项目来说，由于 pnpm 通常的安装方法是 `npm i -g pnpm`，也就是安装当前最新的 pnpm 版本，导致开发人员因安装时间的不同而安装到不同版本的 pnpm。

开发人员间 pnpm 版本不一致所造成的最经典的问题就是低版本的 pnpm 不兼容高版本 pnpm 生成的 `pnpm-lock.yaml`。低版本 pnpm 执行 `pnpm i` 时会忽略并覆盖高版本的 `pnpm-lock.yaml`，导致一个项目的 `pnpm-lock.yaml` 文件总是变来变去（注意 `lockfileVersion` 的变化）：

![lock](/images/blog/16/lock.png)

而被反复覆盖的 `pnpm-lock.yaml` 也失去了其锁定依赖的作用。在我看来，不一致的 pnpm 就是前端项目中最大的不稳定的环境因素。

要锁定一个项目的 pnpm 版本，可以通过 `corepack` 实现。corepack 是一个包管理器的包管理器，可以管理 pnpm 和 yarn 的版本。

Node.js 从 v16.9.0 版本开始，会捆绑安装 corepack。因此对于我们当前常用的 Node.js 版本，基本都可以直接启用 corepack。而 Node.js 从 v25 版本开始，不再捆绑安装 corepack，但我们还可以通过 `npm i -g corepack` 来安装 corepack。

通过 corepack 锁定 pnpm 版本的步骤如下：

1. 启用 corepack：

    ```sh
    corepack enable
    ```

    上面的命令只需要在安装 Node.js 之后执行一次就可以保持 corepack 全局开启。

    要注意的是通过 Node.js 版本管理器管理的不同版本 Node.js 之间的 corepack 通常是隔离的。切换到别的 Node.js 版本之后，如果此版本的 Node.js 未启用过 corepack，也需要执行一次上面的命令来启用 corepack。

2. 在项目的 `package.json` 中指定 pnpm 版本：

    ```json
    {
      "packageManager": "pnpm@9.15.2"
    }
    ```

3. 此时在项目的根目录下执行 pnpm 命令会自动使用我们指定的版本：

    ```sh
    pnpm -v # 打印 9.15.2
    ```

## 锁定依赖，但不仅仅是版本

当我们通过包管理器安装依赖时，在 `package.json` 中会新增以下记录：

```json
{
  "dependencies": {
    "xxx": "^主版本号.次版本号.修订号"
  }
}
```

假设这个版本号是 `^1.2.3`，则其中开头的 `^` 表示这个依赖的实际版本只要满足 `>=1.2.3 <2.0.0` 即可。如果没有 lock 文件，过一段时间后再次安装依赖，实际安装到的依赖版本很可能不是最初所安装的 `1.2.3`，而是满足 `>=1.2.3 <2.0.0` 这个条件的某个最新版本。

这种设计可能是为了让项目的依赖尽量升级次版本和修订版本。因为根据语义化版本的约定，次版本号更新表示引入新功能，修订号更新表示 Bug 修复，而在次版本号和修订号的更新中都不能引入破坏性改动。让依赖升级次版本号和修订号可以在不破坏现有功能的情况下获取到依赖的新功能和 Bug 修复。

然而这仅仅是理想情况。现实是依赖在次版本号甚至修订号中出现破坏性改动的情况屡见不鲜。为了保证一个项目中依赖的稳定性与一致性，我们需要锁定依赖的版本。

最简单的方法是在 `package.json` 中将所有依赖的版本都固定，例如去掉版本号开头的 `^`。这种办法确实在一定程度上可以实现依赖版本锁定。但要说这样就可以高枕无忧了，那倒也不一定。

如果依赖源由于 Bug 甚至是恶意的目的，在我们获取相同版本号的依赖时返回的是不同的依赖内容，此时在 `package.json` 中固定依赖版本的方法就失效了。

而包管理器的 lock 文件则可以解决这个问题。例如 npm 的 `package-lock.json`，pnpm 的 `pnpm-lock.yaml`。lock 文件通过记录依赖的精确版本号和哈希校验值，可以让包管理器确保当前安装的依赖就是最初所安装的依赖。此外，依赖通常也有其自身的依赖，lock 文件记录了整个依赖树的结构与信息，让包管理器得以总是构建出相同的依赖树。因此，通过 lock 文件锁定依赖是最为可靠的。

在包管理器版本一致的前提下，执行 `npm i` 或 `pnpm i` 会遵循 lock 文件中记录的依赖信息来安装依赖。如果安装到的依赖正确无误，则 lock 文件不会出现变化。而如果安装到的依赖与 lock 文件记录的依赖信息不一致，包管理器通常会报出警告，并更新 lock 文件。这时我们应该意识到这是不正常的情况，需要找出原因。

而要让包管理器严格遵循 lock 文件来安装依赖，可以执行 `npm ci` 或 `pnpm i --frozen-lockfile`。当包管理器发现获取到的依赖与 lock 文件记录的依赖信息不一致，会直接报错并退出，不会完成依赖安装，也不会更新 lock 文件。在 CI/CD 环境中，更适合让包管理器严格遵循 lock 文件，当安装依赖出现异常时，直接中止 CI/CD 的流程。

由于包管理器会自动管理 lock 文件，所以实际上并不太需要我们操心。

我们要做的只有两点：

1. 确保一个项目使用相同版本的包管理器，避免由于包管理器版本不兼容导致 lock 文件被反复覆盖，进而失去其锁定依赖的作用。

2. 确保将 lock 文件纳入 `git` 或 `svn` 管理，而不是将 lock 文件排除在版本控制之外。

## 结语

上面虽然简单地介绍了 fnm + corepack 的方案，但这个方案不是唯一解。

工具只是达成目标的手段，我们的目标是保证前端项目的 Node.js、包管理器、依赖的稳定与一致，告别环境的玄学问题。
