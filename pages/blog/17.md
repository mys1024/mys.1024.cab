---
layout: blog
type: md
bid: 17
title: 浅探 @opencode-ai/sdk
time: 2026-01-19T02:54:20.219Z
tags:
  - 技术
  - AI
  - JavaScript
---

## 前言

最近半年各种 AI Agent 大放异彩，很快就成了我们日常开发的利器，如 Claude Code、Codex、Gemini CLI、OpenCode 等。

我们对这些 Agent 的 TUI/GUI 形式应该已经很熟悉了，这两种形式都是围绕与用户实时交互而设计的。但如果想要在非交互式的场景（例如自动化流程中）下使用 Agent，TUI/GUI 形式则不太适用。

在非交互式的场景下，可以使用 Agent 的 SDK，以代码的形式来调用 Agent。以下是几个常用的 Agent 的 SDK 包：

- Claude Code: [@anthropic-ai/claude-agent-sdk](https://www.npmjs.com/package/@anthropic-ai/claude-agent-sdk)
- Codex: [@openai/codex-sdk](https://www.npmjs.com/package/@openai/codex-sdk)
- OpenCode: [@opencode-ai/sdk](https://opencode.ai/docs/sdk)

相比于调用裸的 AI 模型，调用 Agent 的好处非常明显——自带完善的工具调用、任务规划、AGENTS.md 支持、MCP 支持、Skills 支持等，可以很大程度上增强 AI 的能力，也让我们可以在非交互场景下使用与日常开发场景中相同的 Agent，复用 AGENTS.md、MCP、Skills 等资源。

本文接下来要介绍的是 [OpenCode](https://opencode.ai/) 的 SDK `@opencode-ai/sdk`。

## 简单例子

以下是使用 `@opencode-ai/sdk` 的一个简单例子：

```typescript
import { createOpencode } from '@opencode-ai/sdk';

async function main() {
  // 创建 opencode 实例
  const { server, client } = await createOpencode({
    config: {
      provider: {
        openai: {
          options: {
            baseURL: 'https://xxx/v1', // 配置为你的 API base URL
            apiKey: 'sk-xxx', // 配置为你的 API key
          },
        },
      },
    },
  });

  // 创建 session
  const { data: session, error: sessionError } = await client.session.create();
  if (sessionError) {
    return;
  }

  // 发送提示词
  const result = await client.session.prompt({
    path: { id: session.id },
    body: {
      model: { providerID: 'openai', modelID: 'gpt-5.2-codex' }, // 配置为你使用的模型
      parts: [{ type: 'text', text: '帮我统计 src 目录中有多少个文件' }],
    },
  });

  // 错误处理
  if (result.error) {
    console.error(result.error);
    return;
  }

  // 输出结果
  result.data.parts.forEach((part) => {
    if (part.type === 'reasoning' || part.type === 'text') {
      console.log(part.text);
    }
  });

  // 关闭 opencode 实例
  server.close();
}
```

我的提示词为“帮我统计 src 目录中有多少个文件”，执行后稍作等待，可以看到如下输出：

![output1](/images/blog/17/output1.png)

创建 OpenCode 实例时还可以传入更多的配置，可参考[此文档](https://opencode.ai/docs/config/)。

## 流式输出

`client.session.prompt()` 需要等输出结束之后才会返回结果。如果想要实时获取输出的内容，可以使用 `client.event.subscribe()` 来监听输出事件。

以下是通过 `client.event.subscribe()` 实现流式打印输出内容的例子：

```typescript
import { inspect } from 'node:util';
import { stdout } from 'node:process';
import { createOpencode, type OpencodeClient, type Session } from '@opencode-ai/sdk';
import chalk from 'chalk';

async function main() {
  // 创建 opencode 实例
  const { server, client } = await createOpencode({
    config: {
      provider: {
        openai: {
          options: {
            baseURL: 'https://xxx/v1', // 配置为你的 API base URL
            apiKey: 'sk-xxx', // 配置为你的 API key
          },
        },
      },
    },
  });

  // 创建 session
  const { data: session, error: sessionError } = await client.session.create();
  if (sessionError) {
    return;
  }

  // 订阅事件
  subscribeEvents(client, session, server);

  // 发送提示词
  client.session.prompt({
    path: { id: session.id },
    body: {
      model: { providerID: 'openai', modelID: 'gpt-5.2-codex' }, // 配置为你使用的模型
      parts: [{ type: 'text', text: '帮我统计 src 目录中有多少个文件' }],
    },
  });
}

async function subscribeEvents(
  client: OpencodeClient,
  session: Session,
  server: {
    url: string;
    close(): void;
  },
) {
  const events = await client.event.subscribe();

  // 跟踪上一个 part 的类型，在类型变化时换行
  let prevPartType = '';
  const updatePrevPartType = (type: string) => {
    if (type === prevPartType) {
      return;
    }
    if (prevPartType) {
      stdout.write('\n');
    }
    if (type === 'reasoning') {
      stdout.write(chalk.gray('[reasoning] '));
    }
    prevPartType = type;
  };

  // 异步迭代事件流
  for await (const event of events.stream) {
    // 处理消息事件
    if (event.type === 'message.part.updated') {
      const part = event.properties.part;
      const delta = event.properties.delta;
      if (part.sessionID !== session.id) {
        break;
      }
      // 打印文本输出
      if (part.type === 'text' && delta) {
        updatePrevPartType(part.type);
        stdout.write(delta);
      }
      // 打印推理输出
      else if (part.type === 'reasoning' && delta) {
        updatePrevPartType(part.type);
        stdout.write(chalk.gray(delta));
      }
      // 打印工具调用
      else if (part.type === 'tool' && part.state.status === 'completed') {
        updatePrevPartType(part.type);
        const toolCall = {
          input: part.state.input,
          output: part.state.output,
        };
        stdout.write(
          `\n${chalk.cyan(`[tool:${part.tool}]`)} ${inspect(toolCall, { depth: Infinity, maxStringLength: 256, colors: true })}\n`,
        );
      }
    }
    // 结束后关闭 opencode 实例
    else if (
      event.type === 'session.status' &&
      event.properties.sessionID === session.id &&
      event.properties.status.type === 'idle'
    ) {
      await client.session.delete({ path: { id: session.id } });
      server.close();
      events.stream.return(null);
    }
  }
}
```

执行后可以看到如下输出内容被实时打印出来：

![output2](/images/blog/17/output2.png)

OpenCode 的事件类型很丰富，可以获取到普通输出、推理输出、工具调用等内容。以上例子仅处理了小部分事件，可根据需要自行实现更复杂的事件处理。

总的来说，`client.session.prompt()` 的输出是一次性的、完整的，适合提供给后续的业务逻辑。而 `client.event.subscribe()` 的输出是实时的、增量式的，适合实时查看与记录。

## AGENTS.md、MCP 与 Skills

OpenCode TUI 的各种功能在 SDK 中也同样支持，如 AGENTS.md、MCP、Skills 等。下面给出一些验证例子。

### AGENTS.md

在当前工作目录下创建 `AGENTS.md`，然后输入以下内容：

```markdown
## 项目信息

这是一个使用 TypeScript 的 Node.js 项目。

## 规则

使用简体中文与用户交流。
```

然后调用 SDK 并传入提示词“不读取文件，告诉我你掌握的当前项目的信息与规则”，输出如下：

```txt
当前已知信息与规则如下：
- 项目：TypeScript 的 Node.js 项目。
- 规则：必须使用简体中文与用户交流。
- 工作目录：`/home/mys/p/0/opencode-sdk-demo`。
```

可以看出 AGENTS.md 的内容已被加载到 AI 的上下文中。

### MCP

在创建 OpenCode 实例时可在传入的 `config` 中配置 MCP。以配置 context7 为例：

```typescript
const { server, client } = await createOpencode({
  config: {
    mcp: {
      context7: {
        type: 'remote',
        url: 'https://mcp.context7.com/mcp',
      },
    },
    // ...其它配置
  },
});
```

然后调用 SDK 并传入提示词“给出 Vue3 的 ref() 最新文档。”，输出如下：

```txt
[reasoning] **Identifying context usage for Chinese resolution**

Planning to use context7 resolve combined with query or web to handle Chinese language processing.

[tool:context7_resolve-library-id] {
  input: { query: 'Vue3 ref() 最新文档', libraryName: 'vue' },
  output: 'Available Libraries:\n' +
    '\n' +
    'Each result includes:\n' +
    '- Library ID: Context7-compatible identifier (format: /org/project)\n' +
    '- Name: Library or package name\n' +
    '- Description: Short summary\n' +
    '- Code Snippets: Number of available code examples\n' +
    '- Source Reputation: Authority i'... 2105 more characters
}

[reasoning] **Identifying docs source**

I'll use the Vue.js documentation as a reference source for query documentation.

[tool:context7_query-docs] {
  input: { libraryId: '/vuejs/docs', query: 'Vue 3 ref() 文档，包含说明、用法、注意事项与示例' },
  output: '### Initialize Vue 3 app with reactive state using Composition API\n' +
    '\n' +
    'Source: https://github.com/vuejs/docs/blob/main/src/guide/introduction.md\n' +
    '\n' +
    "This JavaScript snippet shows how to set up a Vue 3 application using the Composition API. It utilizes the 'ref' "... 2228 more characters
}

Vue3 的 `ref()` 最新文档在官方文档这里：

- `https://vuejs.org/guide/essentials/reactivity-fundamentals.html#ref`
- `https://vuejs.org/guide/essentials/reactivity-fundamentals.html`（同章节更完整）

**核心要点**
- `ref()` 返回一个包含 `.value` 的响应式对象。
- 在模板中会自动解包，无需写 `.value`。
- 适合基本类型与需要引用语义的对象。

如果你需要中文版本或特定章节（如自动解包、`shallowRef` 对比），告诉我想看的小节。
```

可以看出成功调用了 context7 来获取 Vue3 最新的 `ref()` 的文档。

### Skills

OpenCode 支持 Skills，skill 的放置目录为 `.opencode/skills`，同时也兼容 Claude Code 的 `.claude/skills` 目录。

我们可以写一个简单的 skill 用作测试：

`.opencode/skills/test-skill/SKILL.md`:

```markdown
---
name: test-skill
description: 输出一段测试消息。使用时机为当用户要求测试 skill 是否正常工作时。
---

## 使用时机

当用户要求测试 skill 是否正常工作时。

## 任务

执行此 skill 目录下的 scripts/test.js，然后告诉用户执行结果。
```

`.opencode/skills/test-skill/scripts/test.js`:

```javascript
console.log('skill 正常工作。');
```

然后调用 SDK 并传入提示词“试下 skill 能不能用”，输出如下：

```txt
[tool:skill] {
  input: { name: 'test-skill' },
  output: '## Skill: test-skill\n' +
    '\n' +
    '**Base directory**: /home/mys/p/0/opencode-sdk-demo/.opencode/skills/test-skill\n' +
    '\n' +
    '## 使用时机\n' +
    '\n' +
    '当用户要求测试 skill 是否正常工作时。\n' +
    '\n' +
    '## 任务\n' +
    '\n' +
    '执行此 skill 目录下的 scripts/test.js，然后告诉用户执行结果。'
}

[tool:bash] {
  input: {
    command: 'node "/home/mys/p/0/opencode-sdk-demo/.opencode/skills/test-skill/scripts/test.js"',
    description: 'Runs test-skill test script',
    workdir: '/home/mys/p/0/opencode-sdk-demo'
  },
  output: 'skill 正常工作。\n'
}

已执行 `test-skill`，输出为“skill 正常工作。”
```

可以看出成功读取了 skill，并正确执行。

## 附

OpenCode SDK 文档：[https://opencode.ai/docs/sdk/](https://opencode.ai/docs/sdk/)
